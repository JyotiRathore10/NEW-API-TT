var g = Object.defineProperty;
var f = (a, r, t) => r in a ? g(a, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[r] = t;
var o = (a, r, t) => f(a, typeof r != "symbol" ? r + "" : r, t);
function m(a, r, t) {
  const e = a.slice(0, r);
  for (; e.length < r; )
    e.push(null);
  return e;
}
const T = 1, y = 0, n = {
  i8: Int8Array.BYTES_PER_ELEMENT,
  i16: Int16Array.BYTES_PER_ELEMENT,
  i32: Int32Array.BYTES_PER_ELEMENT,
  i64: BigInt64Array.BYTES_PER_ELEMENT,
  float: Float32Array.BYTES_PER_ELEMENT,
  double: Float64Array.BYTES_PER_ELEMENT
};
class h {
  /**
   * Creates a new BasePointer instance.
   *
   * @param wasm - The Emscripten WebAssembly module instance
   * @param ptr - Pre-allocated memory pointer. If not provided, subclasses
   *   should handle allocation.
   * @protected
   */
  constructor(r, t) {
    /** Raw memory pointer address in WASM heap */
    o(this, "_ptr", 0);
    /** The WebAssembly module instance */
    o(this, "wasm");
    this.wasm = r, this._ptr = t;
  }
  /**
   * Gets the raw memory pointer address.
   *
   * @example
   *     const strPtr = StringPointer.from(wasm, "test");
   *     console.log(strPtr.ptr); // e.g., 1048576
   *
   * @returns The memory address as a number, or 0 if freed
   */
  get ptr() {
    return this._ptr;
  }
  /**
   * Checks if the pointer is valid (non-zero and not freed).
   *
   * @example
   *     const ptr = StringPointer.from(wasm, "test");
   *     console.log(ptr.isValid); // true
   *     ptr.free();
   *     console.log(ptr.isValid); // false
   *
   * @returns True if pointer is valid, false if freed or unallocated
   */
  get isValid() {
    return this._ptr !== 0;
  }
  /**
   * Validates that the pointer is still valid before operations.
   *
   * @throws {Error} If pointer has been freed or is invalid
   * @protected
   */
  validatePointer() {
    if (!this.isValid)
      throw new Error("Cannot operate on freed or invalid pointer");
  }
  /**
   * Frees the allocated WASM memory.
   *
   * After calling this method, the pointer becomes invalid and cannot be used
   * for further operations. This method is idempotent - calling it multiple
   * times is safe.
   *
   * @example
   *     const ptr = StringPointer.from(wasm, "test");
   *     ptr.free(); // Memory is freed
   *     ptr.free(); // Safe to call again
   */
  free() {
    this._ptr !== 0 && (this.wasm._free(this._ptr), this._ptr = 0);
  }
  /**
   * Convenience method that reads the value and immediately frees the memory.
   *
   * This is the recommended way to retrieve values when you don't need to
   * keep the pointer around for multiple operations.
   *
   * @example
   *     const result = StringPointer.from(wasm, "test").readAndFree();
   *     console.log(result); // "test"
   *     // Memory is automatically freed
   *
   * @returns The value stored in memory before freeing
   * @throws {Error} If pointer is invalid
   */
  readAndFree() {
    this.validatePointer();
    const r = this.read();
    return this.free(), r;
  }
  /**
   * Returns a string representation of the pointer for debugging.
   *
   * @example
   *     const ptr = StringPointer.from(wasm, "test");
   *     console.log(ptr.toString()); // "BasePointer(ptr=1048576, valid=true)"
   *
   * @returns Debug string containing pointer address and validity
   */
  toString() {
    return `${this.constructor.name}(ptr=${this._ptr}, valid=${this.isValid})`;
  }
}
class c extends h {
  /**
   * Creates a new ArrayPointer instance.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - The type of each numeric element in the array.
   * @param length - Number of elements in the array.
   * @param ptr - Optional raw pointer to pre-allocated memory. If
   *   `undefined`, memory is allocated.
   */
  constructor(t, e, i, s) {
    super(t, s ?? t._malloc(i * n[e]));
    /** Data type of the elements stored (e.g., "i32", "double"). */
    o(this, "type");
    /** Number of elements in the array. */
    o(this, "length");
    this.type = e, this.length = i;
  }
  /**
   * Creates a new ArrayPointer from a JavaScript number array.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - Type of each numeric element (e.g., "double", "i32").
   * @param input - JavaScript array of numbers to write to WASM memory.
   * @returns A new instance of ArrayPointer.
   */
  static from(t, e, i, s = []) {
    const p = c.alloc(t, e, i);
    return p.write(s), p;
  }
  /**
   * Allocates an empty buffer for a numeric array.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - Type of numeric element stored.
   * @param length - Number of elements to allocate.
   * @returns A new instance of ArrayPointer.
   */
  static alloc(t, e, i) {
    return new c(t, e, i);
  }
  /**
   * Writes a numeric value at a given index in WASM memory.
   *
   * @param loc - Index to write to.
   * @param val - Numeric value to write.
   * @throws If index is out of bounds.
   */
  add(t, e) {
    if (this.validatePointer(), t >= 0 && t < this.length)
      this.wasm.setValue(
        this.ptr + t * n[this.type],
        e,
        this.type
      );
    else
      throw new Error(
        `Out-of-bounds access: tried to write at index ${t} in array of length ${this.length}`
      );
  }
  /**
   * Reads the entire numeric array from WASM memory and trims or pads it to
   * the specified fixed length.
   *
   * @returns A fixed-length array
   */
  read() {
    this.validatePointer();
    const t = n[this.type], e = Array.from(
      { length: this.length },
      (i, s) => this.wasm.getValue(this.ptr + s * t, this.type)
    );
    return m(e, this.length);
  }
  /** Writes a JS array into WASM memory */
  write(t) {
    if (this.validatePointer(), t.length > this.length)
      throw new Error(
        `Array length mismatch. Expected ${this.length}, got ${t.length}`
      );
    t.forEach(
      (e, i) => this.add(i, e)
    );
  }
}
class l {
  /**
   * Converts a JavaScript boolean to a C-style boolean.
   *
   * @example
   *     TypeConverter.boolToC(true); // Returns 1
   *     TypeConverter.boolToC(false); // Returns 0
   *
   * @param value - The JavaScript boolean value
   * @returns 1 for true, 0 for false
   */
  static boolToC(r) {
    return r ? T : y;
  }
  /**
   * Converts a C-style boolean to a JavaScript boolean.
   *
   * @example
   *     TypeConverter.boolFromC(1); // Returns true
   *     TypeConverter.boolFromC(0); // Returns false
   *
   * @param value - The C boolean value (0 or 1)
   * @returns True for non-zero values, false for zero
   */
  static boolFromC(r) {
    return !!r;
  }
  /**
   * Converts a single-character JavaScript string to its ASCII code.
   *
   * @example
   *     TypeConverter.charToC("A"); // Returns 65
   *     TypeConverter.charToC("0"); // Returns 48
   *
   * @param char - A string containing exactly one character
   * @returns The ASCII code (0-255) of the character
   * @throws {Error} If input is not exactly one character
   */
  static charToC(r) {
    if (typeof r != "string" || r.length !== 1)
      throw new Error("Input must be exactly one character");
    const t = r.charCodeAt(0);
    if (t < 0 || t > 255)
      throw new Error(
        `Character '${r}' is outside ASCII range (0-255)`
      );
    return t;
  }
  /**
   * Converts an ASCII code to a single-character JavaScript string.
   *
   * @example
   *     TypeConverter.charFromC(65); // Returns 'A'
   *     TypeConverter.charFromC(48); // Returns '0'
   *
   * @param code - The ASCII code (must be 0-255)
   * @returns A single-character string
   * @throws {Error} If code is outside valid ASCII range
   */
  static charFromC(r) {
    if (!Number.isInteger(r) || r < 0 || r > 255)
      throw new Error(`Invalid ASCII code: ${r}. Must be 0-255`);
    return String.fromCharCode(r);
  }
  /**
   * Validates that a numeric type is supported by the library.
   *
   * @param type - The type to validate
   * @returns True if the type is supported
   * @throws {Error} If the type is not supported
   */
  static validateNumberType(r) {
    if (!(r in n))
      throw new Error(`Unsupported number type: ${r}`);
    return !0;
  }
  /**
   * Gets the size in bytes for a given numeric type.
   *
   * @param type - The numeric type
   * @returns Size in bytes
   * @throws {Error} If type is not supported
   */
  static getTypeSize(r) {
    return this.validateNumberType(r), n[r];
  }
}
class u extends h {
  /**
   * Creates a new BoolPointer. If no `ptr` is given, allocates memory
   * initialized to `false` (0).
   *
   * @param wasm - Emscripten WASM module instance
   * @param ptr - Optional pointer to an existing WASM memory address.
   */
  constructor(r, t) {
    super(r, t ?? r._malloc(n.i8)), t || this.write(!1);
  }
  /**
   * Creates a BoolPointer from a JavaScript boolean.
   *
   * @param wasm - Emscripten WASM module instance
   * @param value - The boolean value to store (true/false).
   * @returns A new instance of BoolPointer.
   */
  static from(r, t) {
    const e = u.alloc(r);
    return e.write(t), e;
  }
  /**
   * Allocates an empty BoolPointer initialized to false.
   *
   * @param wasm - Emscripten WASM module instance
   * @returns A new instance of BoolPointer.
   */
  static alloc(r) {
    return new u(r);
  }
  /**
   * Writes a JavaScript boolean into WASM memory.
   *
   * @param value - The boolean to write.
   */
  write(r) {
    this.validatePointer();
    const t = l.boolToC(r);
    this.wasm.setValue(this.ptr, t, "i8");
  }
  /**
   * Reads the boolean value from WASM memory.
   *
   * @returns The stored JavaScript boolean.
   */
  read() {
    this.validatePointer();
    const r = this.wasm.getValue(this.ptr, "i8");
    return l.boolFromC(r);
  }
}
class d extends h {
  /**
   * Constructs a new `CharPointer`. If `ptr` is not provided, memory is
   * allocated for a single null-terminated char (initialized to `\0`).
   *
   * @param wasm - The Emscripten WebAssembly module instance.
   * @param ptr - Optional pointer to an existing WASM memory address.
   */
  constructor(r, t) {
    super(r, t ?? r._malloc(n.i8)), t || this.write("\0");
  }
  /**
   * Creates a new `CharPointer` from a JavaScript string.\
   * Only the first character is stored (C `char` is a single byte).
   *
   * @param wasm - The Emscripten WebAssembly module instance.
   * @param input - A string from which the first character will be stored.
   * @returns A new instance of `CharPointer`.
   */
  static from(r, t) {
    if (t.length !== 1)
      throw new Error("Input must be exactly one character");
    const e = d.alloc(r);
    return e.write(t), e;
  }
  /**
   * Allocates a new empty buffer for a single character (`char`).
   *
   * @param wasm - The Emscripten WebAssembly module instance.
   * @returns A new zero-initialized `CharPointer`.
   */
  static alloc(r) {
    return new d(r);
  }
  /**
   * Writes a JavaScript string into the allocated WASM memory.\
   * Only the first character of the string will be stored.
   *
   * @param input - The string to write (must be exactly one character).
   * @throws Error if the string length is not exactly one character.
   */
  write(r) {
    this.validatePointer();
    const t = l.charToC(r);
    this.wasm.setValue(this.ptr, t, "i8");
  }
  /**
   * Reads the stored character as a JavaScript string.
   *
   * @returns A one-character string read from WASM memory.
   */
  read() {
    this.validatePointer();
    const r = this.wasm.getValue(this.ptr, "i8");
    return l.charFromC(r);
  }
}
class v extends h {
  /**
   * Creates a new NullPointer instance.
   *
   * Unlike other pointers, this does not need a WASM module.
   */
  constructor() {
    super({}, 0);
  }
  /**
   * Always throws because a NullPointer cannot read memory.
   *
   * @throws {Error} Always throws: "Cannot read from a NullPointer"
   */
  read() {
    throw new Error("Cannot read from a NullPointer");
  }
}
class w extends h {
  /**
   * Creates a new NumberPointer. If no pointer is given, allocates memory for
   * one number.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - The type of each numeric element in the Number.
   * @param ptr - Optional raw pointer to pre-allocated memory. If
   *   `undefined`, memory is allocated.
   */
  constructor(t, e, i) {
    super(t, i ?? t._malloc(n[e]));
    /** Data type of the elements stored (e.g., "i32", "double"). */
    o(this, "type");
    this.type = e;
  }
  /**
   * Creates a new NumberPointer from a JavaScript number Number.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - Type of each numeric element (e.g., "double", "i32").
   * @param input - JavaScript Number of numbers to write to WASM memory.
   * @returns A new instance of NumberPointer.
   */
  static from(t, e, i) {
    const s = w.alloc(t, e);
    return s.write(i), s;
  }
  /** Writes a JS Number into WASM memory */
  write(t) {
    this.validatePointer(), this.add(t);
  }
  /**
   * Allocates an empty buffer for a numeric Number.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - Type of numeric element stored.
   * @param length - Number of elements to allocate.
   * @returns A new instance of NumberPointer.
   */
  static alloc(t, e) {
    return new w(t, e);
  }
  /**
   * Writes a numeric value at a given index in WASM memory.
   *
   * @param val - Numeric value to write.
   * @throws If index is out of bounds.
   */
  add(t) {
    this.validatePointer(), this.wasm.setValue(
      this.ptr,
      t,
      this.type
    );
  }
  /**
   * Reads the entire numeric Number from WASM memory and trims or pads it to
   * the specified fixed length.
   *
   * @returns A fixed-length Number
   */
  read() {
    return this.validatePointer(), this.wasm.getValue(this.ptr, this.type);
  }
}
class E extends h {
  /**
   * Creates a new StringPointer instance.
   *
   * @param wasm - Swisseph Emscripten Module instance
   * @param type - The type of each numeric element in the String.
   * @param length - Number of elements in the String.
   * @param ptr - Optional raw pointer to pre-allocated memory. If
   *   `undefined`, memory is allocated.
   */
  constructor(t, e, i) {
    super(t, i ?? t._malloc(e * n.i8));
    /** Number of character in the String. */
    o(this, "length");
    this.length = e;
  }
  /**
   * Creates a StringPointer from a JavaScript string.
   *
   * @param wasm - Emscripten Module instance
   * @param input - The string to encode and store in WASM memory.
   * @returns A new instance of StringPointer.
   */
  static from(t, e, i = "") {
    const s = E.alloc(t, e + 1);
    return s.write(i), s;
  }
  /**
   * Allocates an empty buffer for a string of given length.
   *
   * @param wasm - Emscripten Module instance
   * @param length - Number of bytes to allocate in WASM memory.
   * @returns A new instance of StringPointer with zero-filled memory.
   */
  static alloc(t, e) {
    return new E(t, e);
  }
  /**
   * Writes a JavaScript string into the allocated WASM memory buffer.
   *
   * @param input - The string to write.
   * @throws Will throw an error if the input string is too long for the
   *   allocated buffer.
   */
  write(t) {
    if (this.validatePointer(), t.length + 1 > this.length)
      throw new Error("String length exceeds buffer size");
    this.wasm.stringToUTF8(t, this.ptr, this.length);
  }
  /**
   * Reads the UTF-8 string from WASM memory.
   *
   * @returns The decoded JavaScript string.
   */
  read() {
    return this.validatePointer(), this.wasm.UTF8ToString(this.ptr, this.length);
  }
}
export {
  c as ArrayPointer,
  h as BasePointer,
  u as BoolPointer,
  y as C_FALSE,
  T as C_TRUE,
  n as C_TYPE_SIZES,
  d as CharPointer,
  v as NullPointer,
  w as NumberPointer,
  E as StringPointer,
  l as TypeConverter
};
//# sourceMappingURL=index.mjs.map
